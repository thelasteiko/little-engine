Not that, we need a log file, statistics and performance information.
Logger:
  What do we need to include in a logger?
  Time:Run Time: Class Method  Note
  What about statistics?
  Have a csv file
  run time
  how many loops
  animations running
  how long some thing took
  modes or windows
  user time in a scene...etc.
  
So what we need to do next is add input from the user, animations,
images and sound.

After these basic components, start on APIs for interface components.

Threading: https://sourceforge.net/p/fxruby/mailman/fxruby-users/?viewmonth=200404&page=1

Input:
http://www.gamedev.net/blog/355/entry-2250186-designing-a-robust-input-handling-system-for-games/

A Word on Data Driven Designs
So far I've been vague as to how all this is actually coded. One option is certainly to hard-code everything: in context A, key Q corresponds to action 7, and so on. A far better option is to make everything data driven. In this approach, we write code once that can be used to handle any context and any input mapping scheme, and then feed it data from a simple file to tell it what contexts exist, and how the mappings work.

The basic layout I typically use looks something like this:

    rawinputconstants.h (a code file) specifies a series of ID codes, usually in an enumeration, corresponding to each raw input (from hardware) that we might handle. These are divided up into "buttons" and "axes." Buttons can map to states or actions, and axes always map to ranges.

    inputconstants.h (a code file) specifies another set of ID codes, this time defining each action, state, and range available in the game.

    contexts.xml (a data file) specifies each context in the game, and provides a list of what inputs are valid in each individual context.

    inputmap.xml (a data file) carries one section per context. Each context section lists out what raw input IDs are mapped to what high-level action/state/range IDs. This file also holds sensitivity configurations for ranged inputs.

    inputranges.xml (a data file) lists each range ID, its raw value range (say, -100 to 100), and how to map this onto a normalized internal value range (such as -1 to 1).

    A code class called RangeConversions loads inputranges.xml and handles converting a raw value to a mapped value.

    A code class called InputContext encapsulates all of the functionality of mapping a single context worth of inputs from raw to high-level IDs, including ranges. Sensitivity configurations are applied here. This class basically just exists to act on the data from inputmap.xml.

    A code class called InputMapper encapsulates the process of holding a list of valid (active) InputContexts. Input is passed into this class from the first-layer code, and out into the third-layer code.

    A code class (usually a POD struct in C++ versions of the system) called MappedInput holds a list of all the input mapped in the current frame, as covered above.

    Each frame (or whenever input is available), the first layer of input code takes all of the available input and packs it into an InputMapper object. Once this is finished, it calls InputMapper.Dispatch() and the InputMapper then calls InputContext.MapInput() for each active context and input. Once the final list of mapped input is compiled into a MappedInput object, the MappedInput is passed into each registered callback, and the high-level game code gets a chance to react to the input.

  Right now the input is a queue which is read from each cycle.
  This is synchronized input.
  We may need asynchronous input for faster paced games.
  Should there be an option to choose?
  I think that having both options would be useful.
  The programmer can use the queue when the program doesn't need to respond immediately.
  Else they can have the scene react right away.
  This would also be based on which scene they are in.
  Ex; A menu doesn't generally need asynchronous responses.

Each game has different input needs.
I would like it if each key had a corresponding response.
Probably cannot be explicit in response but maybe create a
framework.

Is it useful if one action is completed each iteration or should
the action be completed immediately?
  Seems like it would be better to complete it immediately using
  a callback system.

require 'fox/keys'

0x0020 <= main keys <= 0x007E
0x0030 <= numbers <= 0x0039
0x0041 <= upper case <= 0x005A
0x0061 <= lower case <= 0x007A

Look at fox/keys.rb, which defines symbolic constants for all of the
key codes, e.g.

require 'fox/keys'

@input.connect(SEL_KEYPRESS) do |sender, sel, data|
  case data.code
  when KEY_Left
    puts "left"
  when KEY_Right
    puts "right"
  when KEY_Up
    puts "up"
  when KEY_Down
    puts "down"
  end
end

http://stackoverflow.com/questions/522720/passing-a-method-as-a-parameter-in-ruby
I can use this setup to pass code blocks for input:

gaussian = Proc.new do |dist, *args|
  sigma = args.first || 10.0
  ...
end

def weightedknn(data, vec1, k = 5, weightf = gaussian)
  ...
  weight = weightf.call(dist)
  ...
end

what i need to do is sort out how things move
in grid, flat x,y with different animations according to direction
what types of games?
  topdown
  grid based
  2d scroller
  flying
  shooter
  
basically all need different animations for each cardinal direction
code % 4 will give me direction
S:0
W:1
N:2
E:3

leave @ 6:30
